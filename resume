I've written C++ for the last decade and a half, but before I got my degree I
was a reporter and copyeditor on a daily newspaper. Those jobs demand
technical-writer skills, minus the technology: Reporters pull together
conversations to make narrative. Editors clarify.  Project reviews are
performed daily by thousands of customers.

Now as an engineer I've been able to put the tech back into it. Though
"technical writer" isn't my title, I have serious technical writing and editing
to show.

I love this kind of work, and I'm eager to help.

First clip: Designersim (13,000-word user manual)

The longest stretch of my career has been writing C++ for hardware
verification. Once a chip is made bugs are unfixable. We simulated hardware
designs extensively.

At that time our hardware designers did no unit test  -- the verif tool took
weeks to learn and needed too much setup. We were seeing bugs everyone wished
had been caught earlier.

I created a unit sim environment for hardware designers and actively promoted
it using this document.

Since nobody approached me I thought I'd failed, but it turned out to have been
a documentation success story -- designers read the spec and began using the
environment on their own.

Second clip: Editorial skills

This was the opening paragraph of a department vision document that I thought
could be made more exciting. I show it before and after my edit.

Original:

  In the coming decade, workloads running on large-scale HPC and commercial
  systems will increasingly be characterized by complex, multi-faceted
  workflows. These workflows will digest and analyze enormous amounts of data
  of varying types, from varying sources and with varying degrees of
  persistence. These workflows will have huge computational demands and the
  need for cognitive feedback and steering from advanced AI technology. Hence,
  there is an opportunity for a converged, cognitive system architecture that
  can address the needs of both computational worlds. Systems based on this
  architecture will have to be flexible in nature, highly secure, reasonably
  straight forward to program, and highly data capable as well as being
  computationally powerful, cost effective, and energy efficient. This
  document spells out a vision for just such an architecture: [Name Redacted]
  Architecture.

Edited:

  Complex, multifaceted workflows will dominate large-scale HPC and commercial
  systems in the coming decade. Enormous quantities of data -- varied in
  sources, types, and persistence -- will in turn demand extraordinary
  computational power for analysis. A new kind of machine is needed to meet
  both the data and computational dimensions of these workloads. We believe we
  know how to build such a machine -- a [Name Redacted] Architecture -- and
  how also to make it flexible, secure, cost-effective, energy-efficient, and
  realistically programmable.

| maybe not this one:
|   Third clip: Wiki pge
|
|   Classically the first sentence of a news story summarizes what's to follow and
|   entices you to read further. I tried to do this in the opening section of a
|   wiki where I describe a methodology for verifying a new CPU.


Third clip: Extract from a design spec

I struck a deal with a designer whose work I was assigned to verify: If he
explained it to me, I'd write the hardware spec. This is a section from that
spec. The hardware was doing something that had never before been done
commercially and the concepts needed to be explained in detail. The spec was
later praised by a high-ranking engineer as one of the best he'd seen.

  2.2.1 Multithreading Model

  In speculative multithreading, successive sections of sequential code are
  assigned to hardware threads to run simultaneously. Each thread has the
  illusion of executing its task in program order.  It sees its own writes and
  writes that occurred earlier in the program.  It does not see writes that take
  place later in program order even if (because of the concurrent execution)
  these writes have actually taken place earlier in time.

  To sustain the illusion, the L2 gives threads private storage as needed.  It
  lets threads read their own writes and writes from threads earlier in program
  order, but isolates their reads from threads later in program order. Thus, the
  L2 might have several different data values for a single address. Each
  occupies an L2 way, and the L2 records, in addition to the usual
  directory information, a history of which threads have read or written the
  line. A speculative write is never allowed to be written out to main memory.

  Only one situation will break the program-order illusion â€” if a thread earlier
  in program order writes to an address that a thread later in program order has
  already read. The later thread should have read that data, but did not. The
  solution is to kill the later thread and invalidate all the lines it has
  written in the L2, and to repeat this for all younger threads.  On the other
  hand, without this interference a thread can complete successfully, and its
  writes can move to DDR when the line is cast out or flushed.

  ...

  The following sections describe the hardware implementation of the
  multithreading model.




---------------------------------------------------------------------------------------------


I understand the need for clips

I worked in hardware verification -- we'd simulate chip designs looking for bugs.
Hardware designers had no unit test environment to find the easy bugs
before turning the design over to the verifiers. The verification tools were too difficult
for casual use. To fill the gap I created a unit sim environment for hardware designers
and actively promoted it, using the documentation I've enclosed. On the
strength of it, several desigI've programmed C++ for the last decade and a half, but before I got my degree
I was a reporter and copyeditor for a daily newspaper.
Those jobs call for technical-writer skills, minus the technology:
Reporters turn conversations into narrative. Editors coax words into clarity.
And you'd better do it well, since readers pay your salary.

Today I'm an engineer and technology is my second language. While I don't have
a tech writer title, I have tech writing to show you, and I'm
eager to contribute some new writing during Season of Docs.
ners adopted the tool. I didn't
know exactly how many at first, because nobody was asking me questions. I was
happy to find they had gotten everything they needed from the documentation.



Reporters need to get the good stuff out front, and classically
the first sentence summarizes everything below. I submit this
as a good documentation lede -- a swift, comprehensive summary
that makes you want to read further.

For proprietary reasons, I'm unable to share a lot more than this.
I can


I hope the designersim spec shows I can write and organize technical
a large with flashes of humor (the section "Long Goodbyes").



I hope I qualify. I've programmed in C++ for the last 15 years, but before
my engineering degree I was a newspaper reporter and copyeditor. A reporter turns talk into narrative. An editor
reporter, I know how to turn talk into narrative. As an editor I
helped strengthen prose and spot weaknesses. And as an programmer, I
can listen with the ears of both a user and a developer.


